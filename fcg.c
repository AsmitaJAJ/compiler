//Register Descriptor Set Up: 
//This part sets up an individual register’s value in memory space by taking its index into an array of all possible values for that type of register (i32). 
//It also stores information about what kind of operation was performed on it so that subsequent steps can identify which operation happened
//if they’re called multiple times during execution.

//Basic Block Generation: This step involves creating individual blocks within each basic block as well as lines between them 
//so we can keep track of where things are happening at any given moment during execution.
//Instruction Generation For Operations On Registers: This step converts source code statements into machine instructions using information from 
//both our ELF file format files (the ones generated by GCC) as well as other sources such as Bazel’s build system which knows how to generate 
//particular kind of machine code for particular CPUs. This is where we start to see the magic of how compilers work in practice, as they’re able 
//to generate code that’s optimized in various ways based on the type of operation being performed (e.g., addition) and the registers involved (i32). 
//This step can also be thought of as “register allocation” because it’s where we determine which registers will be used for each operation, 
//and how many there are in total. This step uses the information generated in the previous steps as well as other information such as rules about 
//how many registers are needed for certain operations. For example, we might know that 32-bit addition requires two registers: one to hold the value 
//being added, and one for the result of this operation.

//Instruction Scheduling: This step reorders instructions so that they’re executed efficiently on a particular CPU architecture. 
//This step uses information about the execution resources available on each CPU architecture to determine the best order for executing operations. 
//It also considers things like whether or not we have enough registers to store values (if some are in use), or 
//if there’s a bottleneck somewhere else in the pipeline.


#include <stdio.h>
#include <string.h>
#include <stdlib.h>

typedef struct {
    char type[10];    // Type of instruction (assign, add, call)
    char var1[10];    // Variable 1 (for assign, add)
    char var2[10];    // Variable 2 (for add)
    char result[10];  // Result variable (for assign, add)
    char func[10];    // Function name (for call)
    char args[4][10]; // Arguments for the function (for call)
} IRInstruction;

typedef struct {
    FILE *output_file;
    int temp_var_counter;
} CodeGenerator;

void generate_assignment(CodeGenerator *gen, IRInstruction *instr) {
    fprintf(gen->output_file, "MOV %s, %s\n", instr->result, instr->var1);
}

void generate_addition(CodeGenerator *gen, IRInstruction *instr) {
    fprintf(gen->output_file, "ADD %s, %s, %s\n", instr->result, instr->var1, instr->var2);
}

void generate_function_call(CodeGenerator *gen, IRInstruction *instr) {
    // Move arguments into registers (x64 Microsoft calling convention)
    for (int i = 0; i < 4 && strlen(instr->args[i]) > 0; i++) {
        switch (i) {
            case 0: fprintf(gen->output_file, "MOV RCX, %s\n", instr->args[i]); break;
            case 1: fprintf(gen->output_file, "MOV RDX, %s\n", instr->args[i]); break;
            case 2: fprintf(gen->output_file, "MOV R8, %s\n", instr->args[i]); break;
            case 3: fprintf(gen->output_file, "MOV R9, %s\n", instr->args[i]); break;
        }
    }

    // Call the function
    fprintf(gen->output_file, "CALL %s\n", instr->func);
}

void generate_final_code(CodeGenerator *gen, IRInstruction *ir_code, int num_instructions) {
    for (int i = 0; i < num_instructions; i++) {
        if (strcmp(ir_code[i].type, "assign") == 0) {
            generate_assignment(gen, &ir_code[i]);
        } else if (strcmp(ir_code[i].type, "add") == 0) {
            generate_addition(gen, &ir_code[i]);
        } else if (strcmp(ir_code[i].type, "call") == 0) {
            generate_function_call(gen, &ir_code[i]);
        }
    }
}

int main() {
    CodeGenerator gen;
    gen.output_file = fopen("output.asm", "w");
    gen.temp_var_counter = 0;

    if (gen.output_file == NULL) {
        printf("Error opening file for output.\n");
        return 1;
    }

    // Sample IR Code
    IRInstruction ir_code[] = {
        {"assign", "5", "", "RDI", "", {{0}}},
        {"assign", "10", "", "RSI", "", {{0}}},
        {"add", "RDI", "RSI", "RDX", "", {{0}}},
        {"call", "", "", "", "SomeFunction", { "RDI", "RSI", "", "" }},
        {"assign", "RDX", "", "RAX", "", {{0}}}
    };

    // Generate the final assembly code
    generate_final_code(&gen, ir_code, 5);

    fclose(gen.output_file);
    printf("Assembly code has been generated in 'output.asm'.\n");

    return 0;
}
